# -*- coding: utf-8 -*-
"""reV powercurve losses module.

"""
import logging
from abc import ABC, abstractmethod

import numpy as np
from scipy.optimize import minimize_scalar

from reV.utilities.exceptions import reVLossesValueError

logger = logging.getLogger(__name__)


class PowercurveLosses:
    """A converter between annual losses and powercurve transformation.

    Given a target annual loss value, this class facilitates the
    calculation of a powercurve transformation such that the annual
    generation losses incurred by using the transformed powercurve when
    compared to the original (non-transformed) powercurve match the
    target loss as close as possible.

    The underlying assumption for this approach is that some types of
    losses can be realized by a transformation of the powercurve (see
    the values of :obj:`TRANSFORMATIONS` for details on all of the
    powercurve transformations that have been implemented).

    The advantage of this approach is that, unlike haircut losses (where
    a single loss value is applied across the board to all generation),
    the losses are distributed non-uniformly across the powercurve. For
    example, even in the overly simplified case of a horizontal
    translation of the powercurve (which is only physically realistic
    for certain types of losses like blade degradation), the losses are
    distributed primarily across region 2 of the powercurve (the steep,
    almost linear, portion where the generation rapidly increases). This
    means that, unlike with haircut losses, generation is able to reach
    max rating if the wind resource is good enough in a given region.

    Attributes
    ----------
    powercurve : :obj:`Powercurve`
        A :obj:`Powercurve` object representing the "original
        powercurve".
    wind_resource : :obj:`np.array`
        An array containing the wind speeds (i.e. wind speed
        distribution) for the site at which the powercurve will be used.
        This distribution is used to calculate the annual generation
        of the original powercurve as well as any additional calcaulted
        powercurves. The generation values are then compared in order to
        calculate the loss resulting from a transformed powercurve.
    """

    def __init__(self, powercurve, wind_resource):
        """
        Parameters
        ----------
        powercurve : Powercurve
            A :obj:`Powercurve` object representing the turbine
            powercurve. This input is treated as the
            "original powercurve".
        wind_resource : iter
            An iterable containing the wind speeds measured at the site
            where this powercurve will be applied to caulcate
            generation. These values are used to calculate the loss
            resulting from a transformed powercurve compared to the
            generation of the original powercurve. The input
            values should all be non-zero, and the units of
            should match the units of the ``powercurve`` input
            (typically, m/s).
        """
        self.powercurve = powercurve
        self.wind_resource = np.array(wind_resource)
        self._power_gen = None

        _validate_arrays_not_empty(self, array_names=['wind_resource'])
        self._validate_wind_resource()

    def _validate_wind_resource(self):
        """Validate that the input wind resource is non-negative. """
        if not (self.wind_resource >= 0).all():
            msg = "Invalid wind resource input: Contains negative values! - {}"
            msg = msg.format(self.wind_resource)
            logger.error(msg)
            raise reVLossesValueError(msg)

    def annual_losses_with_transformed_powercurve(
        self, transformed_powercurve
    ):
        """Calculate the annual losses from a transformed powercurve.

        This function uses the wind resource data that the object was
        initialized with to calculate the total annual power generation
        with a transformed powercurve. This generation is compared with
        the generation of the original (non-transformed) powercurve to
        compute the total annual losses as a result of the
        transformation.

        Parameters
        ----------
        transformed_powercurve : Powercurve
            A :obj:`Powercurve` object representing the transformed
            powercurve. The power generated with this powercurve will be
            conpared with the power generated by the "original
            powercurve" to calculate annual losses.

        Returns
        -------
        float
            Total losses (%) as a result of a the powercurve
            transformation.
        """
        power_gen_with_losses = transformed_powercurve(self.wind_resource)
        power_gen_with_losses = power_gen_with_losses.sum()
        return (1 - power_gen_with_losses / self.power_gen_no_losses) * 100

    def _obj(self, transformation_variable, target, transformation):
        """Objective function: |output - target|."""
        new_powercurve = transformation.apply(transformation_variable)
        losses = self.annual_losses_with_transformed_powercurve(new_powercurve)
        return np.abs(losses - target)

    def fit(self, target, transformation='horizontal_shift'):
        """Fit a powercurve transformation.

        This function fits a transformation to the input powercurve
        (the one used to initialize the object) to generate an annual
        loss percentage closest to the ``target``. The losses are
        computed w.r.t the generation of the original (non-transformed)
        powercurve.

        Parameters
        ----------
        target : float
            Target value for annual generation losses (%).
        transformation : str
            A string representing the key in the :obj:`TRANSFORMATIONS`
            dictionary corresponding to the powercurve transformation to
            use.

        Returns
        -------
        :obj:`np.array`
            An array containing a transformed powercurve that most
            closely yields the ``target`` annual generation losses.

        Warnings
        --------
        This function attempts to find an optimal transformation for the
        powercurve such that the annual generation losses match the
        ``target`` value, but there is no guarantee that a close match
        can be found, if it even exists. Therefore, it is possible that
        the losses resulting from the transformed powercurve will not
        match the ``target``. This is especially likely if the
        ``target`` is large or if the input powercurve and/or wind
        resource is abnormal.
        """
        transformation = TRANSFORMATIONS[transformation](self.powercurve)
        fit_var = minimize_scalar(
            self._obj,
            args=(target, transformation),
            bounds=transformation.bounds,
            method='bounded'
        ).x
        return transformation.apply(fit_var)

    @property
    def power_gen_no_losses(self):
        """float: Total power generation from original powercurve."""
        if self._power_gen is None:
            self._power_gen = self.powercurve(self.wind_resource).sum()
        return self._power_gen


class Powercurve:
    """A turbine powercurve.

    Attributes
    ----------
    wind_speed : :obj:`np.array`
        An array containing the wind speeds corresponding to the values
        in the :attr:`powercurve` array.
    generation : :obj:`np.array`
        An array containing the generated power at the corresponding
        wind speed in the :attr:`wind_speed` array. This input must have
        at least one positive value, and if a cutoff speed is detected
        (see `Warnings` section below), then all values above that wind
        speed must be set to 0.

    Warnings
    --------
    This class will attempt to infer a cutoff speed from the
    ``generation`` input. Specifically, it will look for a transition
    from the highest rated power down to zero in a single ``wind_speed``
    step of the powercurve. If such a transition is detected, the wind
    speed corresponding to the zero value will be set as the cutoff
    speed, and all calculated powercurves will be clipped at this speed.
    If your input powercurve contains a cutoff speed, ensure that it
    adheres to the expected pattern of dropping from max rated power to
    zero power in a single wind speed step.
    """
    def __init__(self, wind_speed, generation):
        """
        Parameters
        ----------
        wind_speed : iter
            An iterable containing the wind speeds corresponding to the
            generated power values in ``generation`` input. The input
            values should all be non-zero.
        generation : iter
            An iterable containing the generated power at the
            corresponding wind speed in the ``wind_speed`` input. This
            input must have at least one positive value, and if a cutoff
            speed is detected (see `Warnings` section below), then all
            values above that wind speed must be set to 0.
        """
        self.wind_speed = np.array(wind_speed)
        self.generation = np.array(generation)
        self._cutoff_wind_speed = None

        _validate_arrays_not_empty(
            self, array_names=['wind_speed', 'generation']
        )
        self._validate_wind_speed()
        self._validate_generation()

    def _validate_wind_speed(self):
        """Validate that the input wind speed is non-negative. """
        if not (self.wind_speed >= 0).all():
            msg = "Invalid wind speed input: Contains negative values! - {}"
            msg = msg.format(self.wind_speed)
            logger.error(msg)
            raise reVLossesValueError(msg)

    def _validate_generation(self):
        """Validate the input generation. """
        if not (self.generation > 0).any():
            msg = "Invalid generation input: Found no positive values! - {}"
            msg = msg.format(self.generation)
            logger.error(msg)
            raise reVLossesValueError(msg)

        if 0 < self.cutoff_wind_speed < np.inf:
            cutoff_windspeed_ind = np.where(
                self.wind_speed >= self.cutoff_wind_speed
            )[0].min()
            if (self.generation[cutoff_windspeed_ind:]).any():
                msg = ("Invalid generation input: Found non-zero values above "
                       "cutoff! - {}")
                msg = msg.format(self.generation)
                logger.error(msg)
                raise reVLossesValueError(msg)

    @property
    def cutoff_wind_speed(self):
        """float or :obj:`np.inf`: The detected cutoff wind speed."""
        if self._cutoff_wind_speed is None:
            ind = np.argmax(self.generation[::-1])
            # pylint: disable=chained-comparison
            if ind > 0 and self.generation[-ind] <= 0:
                self._cutoff_wind_speed = self.wind_speed[-ind]
            else:
                self._cutoff_wind_speed = np.inf
        return self._cutoff_wind_speed

    def __eq__(self, other):
        return np.isclose(self.generation, other).all()

    def __ne__(self, other):
        return not np.isclose(self.generation, other).all()

    def __lt__(self, other):
        return self.generation < other

    def __le__(self, other):
        return self.generation <= other

    def __gt__(self, other):
        return self.generation > other

    def __ge__(self, other):
        return self.generation >= other

    def __len__(self):
        return len(self.generation)

    def __getitem__(self, key):
        return self.generation[key]

    def __call__(self, wind_speed):
        """Calculate the powercurve value for the given ``wind_speed``.

        Parameters
        ----------
        wind_speed : :obj:`int` | :obj:`float` | :obj:`list` | :obj:`np.array`
            Wind speed value corresponding to the desired powerrcurve
            value.

        Returns
        -------
        float | :obj:`np.array`
            The powercurve value(s) for the input wind speed(s).
        """
        if isinstance(wind_speed, (int, float)):
            wind_speed = [wind_speed]
        new_pc = np.interp(wind_speed, self.wind_speed, self.generation)
        if self.cutoff_wind_speed:
            new_pc[wind_speed >= self.cutoff_wind_speed] = 0
        return new_pc


class PowercurveLossesMixin:
    """Mixin class for :class:`reV.SAM.generation.AbstractSamWind`.

    Warning
    -------
    Using this class for anything excpet as a mixin for
    :class:`~reV.SAM.generation.AbstractSamWind` may result in unexpected
    results and/or errors.
    """

    POWERCURVE_CONFIG_KEY = 'reV-powercurve_losses'
    """Specify powercurve loss target in the config file using this key."""

    def add_powercurve_losses(self):
        """Adjust powercurve in SAM config file to account for losses.

        This function reads the information in the
        ``reV-powercurve_losses`` key of the ``sam_sys_inputs``
        dictionary and computes a new powercurve that accounts for the
        loss percentage specified from that input. If no powercurve loss
        info is specified in ``sam_sys_inputs``, the powercurve will not
        be adjusted.

        See Also
        --------
        :class:`PowercurveLosses` : Powercurve re-calculation.

        """
        target_losses = self.sam_sys_inputs.pop(
            self.POWERCURVE_CONFIG_KEY, None
        )
        if target_losses is None:
            return

        wind_speed = self.sam_sys_inputs['wind_turbine_powercurve_windspeeds']
        generation = self.sam_sys_inputs['wind_turbine_powercurve_powerout']
        powercurve = Powercurve(wind_speed, generation)

        wind_resource = [d[-2] for d in self['wind_resource_data']['data']]
        pc_losses = PowercurveLosses(powercurve, wind_resource)

        new_curve = pc_losses.fit(target_losses)
        self.sam_sys_inputs['wind_turbine_powercurve_powerout'] = new_curve


class PowercurveTransformation(ABC):
    """Base class for powercurve transformations.

    Attributes
    ----------
    powercurve : :obj:`Powercurve`
        A :obj:`Powercurve` object representing the "original
        powercurve".
    """
    def __init__(self, powercurve):
        """
        Parameters
        ----------
        powercurve : Powercurve
            A :obj:`Powercurve` object representing the turbine
            powercurve. This input is treated as the "original
            powercurve".
        """
        self.powercurve = powercurve

    @abstractmethod
    def apply(self, transformation_var):
        """Apply a transformation to the original powercurve."""

    @property
    @abstractmethod
    def bounds(self):
        """tuple: Bounds on the transformation_var."""


class HorizontalPowercurveTransformation(PowercurveTransformation):
    """Utility for applying horizontal powercurve shifts.

    Attributes
    ----------
    powercurve : :obj:`Powercurve`
        A :obj:`Powercurve` object representing the "original
        powercurve".
    """

    def apply(self, transformation_var):
        """Apply a horizontal shift to the original powercurve.

        This function shifts the original powercurve horizontally
        by the given amount and truncates any power above the cutoff
        speed (if one was detected).

        Parameters
        ----------
        transformation_var : float
            The amount to shift the original powercurve by, in wind
            speed units (typically, m/s).

        Returns
        -------
        :obj:`Powercurve`
            An new powercurve containing the generation values from the
            shifted powercurve.
        """
        new_gen = self.powercurve(
            self.powercurve.wind_speed - transformation_var
        )
        mask = self.powercurve.wind_speed >= self.powercurve.cutoff_wind_speed
        new_gen[mask] = 0

        new_curve = Powercurve(self.powercurve.wind_speed, new_gen)
        self._validate_shifted_powercurve(new_curve)
        return new_curve

    def _validate_shifted_powercurve(self, new_curve):
        """Ensure new powercurve has some non-zero generation. """
        mask = [
            self.powercurve.wind_speed <= self.powercurve.cutoff_wind_speed
        ]
        min_expected_power_gen = self.powercurve[self.powercurve > 0].min()
        if not (new_curve[mask] > min_expected_power_gen).any():
            msg = ("Calculated powercurve is invalid. No power generation "
                   "below the cutoff wind speed ({} m/s) detected. Target "
                   "loss percentage  may be too large! Please try again with "
                   "a lower target value.")
            msg = msg.format(self.powercurve.cutoff_wind_speed)
            logger.error(msg)
            raise reVLossesValueError(msg)

    @property
    def bounds(self):
        """tuple: Bounds on the powercurve shift for the fitting procedure."""
        min_ind = np.where(self.powercurve)[0][0]
        max_ind = np.where(self.powercurve[::-1])[0][0]
        max_shift = (
            self.powercurve.wind_speed[-max_ind]
            - self.powercurve.wind_speed[min_ind]
        )
        return (0, max_shift)


TRANSFORMATIONS = {
    'horizontal_shift': HorizontalPowercurveTransformation
}
"""Implemented powercurve transformations."""


def _validate_arrays_not_empty(obj, array_names=None):
    """Validate that the input data arrays are not empty. """
    array_names = array_names or []
    for name in array_names:
        try:
            arr = getattr(obj, name)
        except AttributeError:
            continue
        if not arr.size:
            msg = "Invalid {} input: Array is empty! - {}"
            msg = msg.format(name.replace('_', ' '), arr)
            logger.error(msg)
            raise reVLossesValueError(msg)
